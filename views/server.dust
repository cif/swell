# Server

### Overview

The server is a collection of node modules each which handle different aspects of the request and response pipeline. This makes extending the capabilities of each module clean. In most cases, extensions will be implemented in **middleware.js**. For example, if you wanted to install [Passport](http://passportjs.org/) as your authentication service, then all you would have to do is install the module with npm, and add the appropriate routes to the middleware.js setup() method.

### Pipeline
The server modules handle the request / response flow in left to right order:
<div class="flow">
  <h5>server.js</h5>
  <p><b>server/server.js</b> instantiates <a href="http://nodejs.org/api/http.html">HTTP</a>, <a href="https://www.npmjs.org/package/express">express</a> as well as the <a href="http://expressjs.com/4x/api.html#middleware">middleware</a>, and the other components. It also <b>watches for changes to swell.js</b> and reloads them for save n' go development.</p>
</div>

<div class="flow">
  <h5>middleware.js</h5>
  <p><b>server/middlware.js</b> sets up static asset routes, the <a href="https://github.com/krakenjs/adaro">dust view engine</a>, sessions and cookies as well as static JSON. It is first in line, so any <b>custom route handlers you specify</b> here will take precedence over router.js</p>
</div>

<div class="flow">
  <h5>router.js</h5>
  <p><b>server/router.js</b> handles routes specified by the app configuration as well as <b>automatic mapping to responder object.method()</b> from uri patterns.</p>
</div>

<div class="flow">
  <h5>swell.js</h5>
  <p><b>server/swell.js</b> consits of the swell core coffeescript objects as well as models, collections and responders. The <b>methods it contains are called by the router</b> which in turn passes the response callback to render.js</p>
</div>

<div class="flow">
  <h5>socket.js</h5>
  <p><b>server/socket.js</b> handles socket broadcasts returned to router.js and sends the packets to appropriately subscribed clients.</p>
</div>

<div class="flow">
  <h5>render.js</h5>
  <p><b>server/render.js</b> sends the appropriate final headers and <b>HTML/JSON/XML output</b> to the client as specified by swell.js object methods.</p>
</div>

### Middleware

Middleware is the first stop on the request pipeline. Any route matching functions implemented in **server/middelware.js** will take priority over the default application routes. This is useful in the event you want to make use of **regular expression** route matching, or require more control over the response object for certain routes. 

Here's a simple example handling a request via regex matched route in middleware.js (taken from [the expressjs docs](http://expressjs.com/4x/api.html#middleware))

    app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
        var from = req.params[0];
        var to = req.params[1] || 'HEAD';
        res.send('commit range ' + from + '..' + to);
    });


### Routes

There are two ways in which requests are routed to a responder object method (located in server/swell.js): 

**1. swell.json** allows you to directly map routes to your responder object methods using your configuration file. Example:


    "/widgets/:id" : "Widgets.view"

 
**2. URI inflection** will automatically map request URIs to the responder object.method of the same pattern. For example, a GET request to /widgets/ would call Widgets.get(*request*,*callback*) and a request to /widgets/by_price/ would map to Widgets.by_price(*request*,*callback*)


### Responders

Responders are objects instantiated and called by router.js on each request. Methods defined within them take two arguments, *request* and *callback*. The request is esentially the raw req object from the express route along with any query string, multipart / form data stored in **request.data**. The callback function takes the arguments (*err*, *data*, *emit*) which are then passed onto render.js and socket.js if an emit argument is passed.

*A simple router "Examples" (written in coffeescript):*

    class Examples extends swell.Responder
  
      collection: collections.Examples
      expose_rest: true
  
      color: (request, callback) =>
        new @collection @config, (err, @collection) =>
          @collection.query color:request.data.color, callback 

In this example, a GET request to */examples/color/?color=red* would return a list of examples matching color:'red'. Additional methods can be created and will map automatically via string inflection. Responder classes are all compiled into **server/swell.js**. When watching, changes will be reflected in each new request made to the server.


### Collections

Collection objects are the primary objects your responders will interact with. swell.Collection (server) methods are similar to Backbone.js on the client, the core of them being **fetch, where, get, add, update,** and **remove**.  Additionaly, Collection objects have a few shortcut properties for faster list loading, simple sorting and more.

*An collection "Examples" (written in coffeescript):*

    class Examples extends swell.Collection
  
      model: models.Example
      url: '/examples/'
      resource: 'mongo'
      store: 'examples'
      sort_by: 'sort_order'
      list: ['_id','name']
     

It's common these days for applications to use many data sources. For that reason Collections **each subscribe to their own data source**. Keep in mind that *your implementations* of any swell.Collection will be  **shared by the client**, so be careful not to override the core client side methods and properties found in [Backbone.Collection](http://backbonejs.org/#Collection)


### Models

Models are objects which define field keys and data types to be persisted on the server. Both the client and server share a common core validate(*attrs*) method (taken from <a href="http://backbonejs.org/#Model-validate">BackboneJS</a>) which validates and sanitizes data within your app. As with collecitons, your implementations are **shared by the client**, so be careful not to override [Backbone.Model](http://backbonejs.org/#Model) core functionality.

*A simple "Example" model (written in coffeescript):*

    class Example extends swell.Model
      
      idAttribute: '_id'
  
      fields:
        name:
          type: 'string'
          not_empty: true
          not: 'bad string'
          message: 'Name cannot be "bad string"'
    
        color:
          type: 'string'
          expr: /^#([0-9a-f]{3}|[0-9a-f]{6})$/
          message: 'Colors must be hex values'
    





_____________
{>"partials/credit"/}